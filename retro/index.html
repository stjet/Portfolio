<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Retro">
    <meta name="description" content="The retro version of my website.">
    <title>Retro</title>
    <link rel="icon" type="image/x-icon" href="/tiny-favicon.png" />
    <link href="retro.css" rel="stylesheet" type="text/css" />
    <!--To do: update my opinon site-->
    <!--<meta http-equiv="Onion-Location" content="http://eecflincupi352qlelnar7ahghmhrmiqil4p5cwjwimidsrwqxtlhbyd.onion/retro">-->
  </head>
  <body>
    <div id="desktop">
      <div class="window" id="start-window" style="left: 35px; top: 35px;">
        <div class="window-top">
          <div class="window-title">
            <span>Start</span>
          </div>
          <div class="window-top-buttons">
            <button class="button-base window-top-button"><span class="button-inside button-x">x</span></button>
          </div>
        </div>
        <div class="window-content">
          <h2 id="welcome-h">Welcome to my <span id="www">World Wide Web</span> page!</h2>
          <div id="start-grid">
            <div id="start-intro">
              <h3>Hola, I'm Prussia</h3>
              <p>I like programming. And websites.</p>
              <p>Not sure what else to say here. Oh, this webpage is inspired by Windows NT and zutomayo.net.</p>
              <noscript>Your Javascript is disabled btw. That's fine but don't expect any of the buttons to work :)</noscript>
            </div>
            <div id="start-buttons">
              <h3>Stuff I like:</h3>
              <ul id="stuff-i-like">
                <li><button class="button-base outer-facing" onclick="open_window(event, 'Music')">Music</button></li>
                <li><button class="button-base outer-facing" onclick="open_window(event, 'Wikipedia')">Wikipedia</button></li>
                <li><button class="button-base outer-facing" onclick="open_window(event, 'Programming')">Programming</button></li>
                <li><button class="button-base outer-facing" onclick="open_window(event, 'Minesweeper')">Minesweeper</button></li>
              </ul>
            </div>
          </div>
        </div>
      </div>
      <div class="window" id="music-window" style="left: 155px; top: 75px;">
        <div class="window-top">
          <div class="window-title">
            <span>Music</span>
          </div>
          <div class="window-top-buttons">
            <button class="button-base window-top-button"><span class="button-inside button-x">x</span></button>
          </div>
        </div>
        <div class="window-content">
          <h2>Some songs I like</h2>
          <div id="music-container">
            <div class="song">
              <div class="album-cover-container">
                <img src="album-covers/hisohiso-banashi.png" title="Hisohiso Banashi - I do not own the album cover image yada yada"/>
              </div>
              <div class="song-info">
                <h4><ruby>グラスとラムレーズン<rp>(</rp><rt>Glass to Rum Raisin</rt><rp>)</rp></ruby></h4>
                <span class="song-artist" title="hint3">by Zutomayo</span>
                <p>Some more by the same artist: "JK Bomber", "Inemuri Enseitai", "Samayoi Yoi Ondo", "Inner Heart"</p>
              </div>
            </div>
            <div class="song">
              <div class="album-cover-container">
                <img src="album-covers/dakara-boku-wa-ongaku-wo-yameta.png" title="Dakara Boku wa Ongaku wo Yameta - I do not own the album cover image yada yada"/>
              </div>
              <div class="song-info">
                <h4><ruby>五月は花緑青の窓辺から<rp>(</rp><rt>Gogatsu wa Hanarokushou no Madobe kara</rt><rp>)</rp></ruby></h4>
                <span class="song-artist">by Yorushika</span>
                <p>Some more by the same artist: "Robber and Bouquet", "Voice", "The Old Man and the Sea", "Hitchcock"</p>
              </div>
            </div>
            <div class="song">
              <div class="album-cover-container">
                <img src="album-covers/odds-and-ends.png" title="Odds and Ends - I do not own the album cover image yada yada"/>
              </div>
              <div class="song-info">
                <h4><ruby>夜間飛行<rp>(</rp><rt>Yakanhikou</rt><rp>)</rp></ruby></h4>
                <span class="song-artist">by Nishina</span>
                <p>Some more by the same artist: "Ainikoi", "Tokyo Marble", "Kedamono no Friends", "Yoruninatte"</p>
              </div>
            </div>
            <div class="song">
              <div class="album-cover-container">
                <img src="album-covers/spd-gar.png" title="Spd Gar - I do not own the album cover image yada yada"/>
              </div>
              <div class="song-info">
                <h4>Don't You Want Me</h4>
                <span class="song-artist">by PSYQUI</span>
                <p>Some more by the same artist: "Raise Your Hands", "Endroll", "Funk Assembly", "Education"</p>
              </div>
            </div>
            <div class="song">
              <div class="album-cover-container">
                <img src="album-covers/we-have-fed-you-all-a-thousand-years.png" title="We Have Fed You All A Thousand Years - I do not own the album cover image yada yada"/>
              </div>
              <div class="song-info">
                <h4>The Preacher and the Slave</h4>
                <span>performed by Utah Phillips</span>
                <p>Some more by the same artist: "Bread and Roses", "Halleluja, I'm a Bum", "The Popular Wobbly", "Solidarity Forever"</p>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="window" id="wikipedia-window" style="left: 45px; top: 65px;">
        <div class="window-top">
          <div class="window-title">
            <span>Wikipedia<span id="wikipedia-hidden">hint2 2023 27th jan did you know ww1</span></span>
          </div>
          <div class="window-top-buttons">
            <button class="button-base window-top-button"><span class="button-inside button-x">x</span></button>
          </div>
        </div>
        <div class="window-content">
          <iframe id="wikipedia-iframe"></iframe>
        </div>
      </div>
      <div class="window" id="programming-window" style="left: 95px; top: 65px;">
        <div class="window-top">
          <div class="window-title">
            <span>Programming</span>
          </div>
          <div class="window-top-buttons">
            <button class="button-base window-top-button"><span class="button-inside button-x">x</span></button>
          </div>
        </div>
        <div class="window-content">
          <h2>Programming stuff</h2>
          <p>My favourite language at the moment is <b>Typescript</b> or maybe <b>Scheme</b>, but I'm pretty familiar with Rust, Python, and obviously HTML/CSS/JS. I also know a bit of Ruby and Solidity.</p>
          <p>Most of my projects can be found on my <a href="https://github.com/stjet">Github</a> or the <a href="/">main page</a> of my website. Check out <a href="https://mingde.prussia.dev">mingde</a>, which I was inspired to make after finishing this page.</p>
          <hr/>
          <p>For fun, here are some recreated Window NT programs:</p>
          <div id="programs-list">
            <button class="button-base outer-facing" onclick="open_window(event, 'Terminal')">Terminal</button>
            <button class="button-base outer-facing" onclick="open_window(event, 'Calculator')">Calculator</button>
          </div>
        </div>
      </div>
      <div class="window" id="minesweeper-window" style="left: 15px; top: 105px;">
        <div class="window-top">
          <div class="window-title">
            <span>Minesweeper <span id="minesweeper-status"></span></span>
          </div>
          <div class="window-top-buttons">
            <button class="button-base window-top-button"><span class="button-inside button-x">x</span></button>
          </div>
        </div>
        <div class="window-content" id="minesweeper-container">
        </div>
      </div>
      <div class="window" id="terminal-window" style="left: 25px; top: 85px;">
        <div class="window-top">
          <div class="window-title">
            <span>Terminal</span>
          </div>
          <div class="window-top-buttons">
            <button class="button-base window-top-button"><span class="button-inside button-x">x</span></button>
          </div>
        </div>
        <div class="window-content">
          <p>Prussia's Terminal [version 0.4.2]</p>
          <p>a joke about copyright here</p>
          <p>type 'help' for help</p>
          <br>
          <div id="terminal-responses">
          </div>
          <div id="terminal-input-container"><span id="current-path">/></span> <input type="text" id="terminal-command-input"/></div>
        </div>
      </div>
      <div class="window" id="calculator-window" style="left: 15px; top: 105px;">
        <div class="window-top">
          <div class="window-title">
            <span>Calculator</span>
          </div>
          <div class="window-top-buttons">
            <button class="button-base window-top-button"><span class="button-inside button-x">x</span></button>
          </div>
        </div>
        <div class="window-content">
          <div id="calc-input">
            <div>
              <input id="calc-input-actual" type="text" value="not all buttons work" disabled/>
            </div>
          </div>
          <div id="calc-first-row">
            <div id="calc-blank" class="inner-facing calc-btn calc-reg"></div>
            <div id="calc-first-row-right">
              <button class="outer-facing calc-btn calc-maroon calc-long">Back</button>
              <button class="outer-facing calc-btn calc-maroon calc-long">CE</button>
              <button class="outer-facing calc-btn calc-maroon calc-long">C</button>
            </div>
          </div>
          <div id="calc-container">
            <div id="calc-column">
              <button class="outer-facing calc-btn calc-red calc-reg">MC</button>
              <button class="outer-facing calc-btn calc-red calc-reg">MR</button>
              <button class="outer-facing calc-btn calc-red calc-reg">MS</button>
              <button class="outer-facing calc-btn calc-red calc-reg">M+</button>
            </div>
            <div id="calc-grid">
              <button class="outer-facing calc-btn calc-blue calc-reg">7</button>
              <button class="outer-facing calc-btn calc-blue calc-reg">8</button>
              <button class="outer-facing calc-btn calc-blue calc-reg">9</button>
              <button class="outer-facing calc-btn calc-red calc-reg">/</button>
              <button class="outer-facing calc-btn calc-darkblue calc-reg">sqrt</button>
              <button class="outer-facing calc-btn calc-blue calc-reg">4</button>
              <button class="outer-facing calc-btn calc-blue calc-reg">5</button>
              <button class="outer-facing calc-btn calc-blue calc-reg">6</button>
              <button class="outer-facing calc-btn calc-red calc-reg">*</button>
              <button class="outer-facing calc-btn calc-darkblue calc-reg">%</button>
              <button class="outer-facing calc-btn calc-blue calc-reg">1</button>
              <button class="outer-facing calc-btn calc-blue calc-reg">2</button>
              <button class="outer-facing calc-btn calc-blue calc-reg">3</button>
              <button class="outer-facing calc-btn calc-red calc-reg">-</button>
              <button class="outer-facing calc-btn calc-darkblue calc-reg">1/x</button>
              <button class="outer-facing calc-btn calc-blue calc-reg">0</button>
              <button class="outer-facing calc-btn calc-blue calc-reg">+/-</button>
              <button class="outer-facing calc-btn calc-blue calc-reg">.</button>
              <button class="outer-facing calc-btn calc-red calc-reg">+</button>
              <button class="outer-facing calc-btn calc-red calc-reg">=</button>
            </div>
          </div>
        </div>
      </div>
      <div class="window" id="himitsu-window" style="left: 35px; top: 90px;">
        <div class="window-top">
          <div class="window-title">
            <span>秘密</span>
          </div>
          <div class="window-top-buttons">
            <button class="button-base window-top-button"><span class="button-inside button-x">x</span></button>
          </div>
        </div>
        <div class="window-content">
          <p id="secret-intro"></p>
          <ul id="secret-list">
            <li id="secret-1" class="spoiler"></li>
            <li id="secret-2" class="spoiler"></li>
            <li id="secret-3" class="spoiler"></li>
          </ul>
          <p id="secret-project"></p>
        </div>
      </div>
      <div id="taskbar">
        <div>
          <div id="taskbar-start" class="outer-facing" title="Click to reopen the Start window">
            <span>Start</span>
          </div>
        </div>
        <div id="taskbar-tabs">
        </div>
        <div id="taskbar-time-container">
          <div id="taskbar-time" class="inner-facing" title="Unrelated to the magazine">
            <span id="time">00:00</span>
          </div>
        </div>
      </div>
    </div>
    <div id="portrait-warning">
      <p>Hey bro! This site doesn't really work in portrait mode. Flip the phone to landscape mode.</p>
    </div>
    <script>
      //in order of things I want to do
      //for scripting, variables should work in commands too
      //todo: chat client? lol
      //todo: implement desktop shortcuts that run pscript?
      //todo: flagging in minesweeper? probably not needed
      //todo: import and export file for wallpaper, file system state

      let current_window = "start";
      let window_z_index = 1;

      function change_current_window(new_window) {
        document.getElementById("taskbar-tabs").querySelectorAll(".inner-facing").forEach((tab) => {
          tab.classList.remove("inner-facing");
          tab.classList.add("outer-facing")
        });
        current_window = new_window;
        document.getElementById("toolbar-tab-"+new_window).classList.add("inner-facing");
        document.getElementById("toolbar-tab-"+new_window).classList.remove("outer-facing");
        window_z_index++;
        document.getElementById(new_window+"-window").style.zIndex = window_z_index;
      }

      //update time
      function refresh_time() {
        let hours = (new Date()).getHours();
        let minutes = (new Date()).getMinutes();
        document.getElementById("time").textContent = `${String(hours).length === 1 ? `0${hours}` : hours}:${String(minutes).length === 1 ? `0${minutes}` : minutes}`;
      }
      refresh_time();
      setInterval(refresh_time, 55000);

      //close buttons
      function recount_taskbar_tabs() {
        let tabs = document.querySelectorAll(".taskbar-tab");
        if (tabs.length < 5) {
          tabs.forEach((tab) => {
            tab.classList.add("taskbar-tab-less-than-5");
            tab.classList.remove("taskbar-tab-more-than-7");
          });
        } else if (tabs.length > 7) {
          tabs.forEach((tab) => {
            tab.classList.remove("taskbar-tab-less-than-5");
            tab.classList.add("taskbar-tab-more-than-7");
          });
        } else {
          tabs.forEach((tab) => {
            tab.classList.remove("taskbar-tab-less-than-5");
            tab.classList.remove("taskbar-tab-more-than-7");
          });
        }
      }

      document.querySelectorAll(".button-x").forEach((x) => {
        x.parentElement.onclick = (event) => {
          //hide window
          let window_obj = x.parentElement.parentElement.parentElement.parentElement;
          window_obj.style.display = "none";
          document.getElementById("toolbar-tab-"+window_obj.id.replace("-window", "")).remove();
          recount_taskbar_tabs();
          event?.stopPropagation();
        };
      });

      //drag the window tops
      function px_to_int(px) {
        return Number(px.replace("px", ""));
      }
      function int_to_px(int) {
        return String(int)+"px";
      }
      document.querySelectorAll(".window-top").forEach((top) => {
        let start_window_coords;
        let start_mouse_coords;
        function m_down_handler(event) {
          start_mouse_coords = [event.clientX, event.clientY];
          //coords of window
          start_window_coords = [px_to_int(top.parentElement.style.left), px_to_int(top.parentElement.style.top)];
        }
        top.onmousedown = m_down_handler;
        top.ontouchstart = (event) => m_down_handler(event.touches[0]);
        function m_up_handler() {
          start_mouse_coords = undefined;
          start_window_coords = undefined;
        }
        document.addEventListener("mouseup", m_up_handler);
        document.addEventListener("touchend", m_up_handler);
        function m_move_handler(event) {
          if (!start_mouse_coords || !start_window_coords) return;
          //change window coords
          let current_mouse_coords = [event.clientX, event.clientY];
          let delta_x = current_mouse_coords[0]-start_mouse_coords[0];
          let delta_y = current_mouse_coords[1]-start_mouse_coords[1];
          let new_window_top = start_window_coords[1]+delta_y;
          let new_window_left = start_window_coords[0]+delta_x;
          top.parentElement.style.top = int_to_px(new_window_top);
          top.parentElement.style.left = int_to_px(new_window_left);
          //don't allow user to drag window below taskbar, and make sure window top is visible
          if (new_window_top > window.innerHeight-38-25) {
            top.parentElement.style.top = `${window.innerHeight-38-25}px`;
          }
          if (new_window_top < 0) {
            top.parentElement.style.top = "0px";
          }
          if (new_window_left > window.innerWidth-25) {
            top.parentElement.style.left = `${window.innerWidth-25}px`;
          }
          if (new_window_left < -top.parentElement.clientWidth+25) {
            top.parentElement.style.left = `${-top.parentElement.clientWidth+25}px`;
          }
        }
        document.addEventListener("mousemove", m_move_handler);
        document.addEventListener("touchmove", (event) => m_move_handler(event.touches[0]));
      });

      //window expanding/shrinking
      document.querySelectorAll(".window").forEach((window_obj) => {
        let mouse_down = false;
        let change = false;
        let start_dimensions;
        let start_mouse_coords;
        window_obj.addEventListener("mousemove", (event) => {
          change = false;
          if (event.clientX > px_to_int(window_obj.style.left)+window_obj.offsetWidth-10) {
            document.body.style.cursor = "col-resize";
            change = "x";
          } else if (document.body.style.cursor === "col-resize") {
            if (!mouse_down) {
              document.body.style.cursor = "auto";
              change = false;
            }
            if (mouse_down) {
              window_obj.style.width = int_to_px(start_dimensions[0] + (event.clientX - start_mouse_coords[0]));
            }
          }
          if (event.clientY > px_to_int(window_obj.style.top)+window_obj.offsetHeight-10) {
            document.body.style.cursor = "row-resize";
            change = "y";
          } else if (document.body.style.cursor === "row-resize") {
            if (!mouse_down) {
              document.body.style.cursor = "auto";
              change = false;
            }
            if (mouse_down) {
              window_obj.style.height = int_to_px(start_dimensions[1] + (event.clientY - start_mouse_coords[1]));
            }
          }
        });
        window_obj.addEventListener("mousedown", (event) => {
          if (document.body.style.cursor === "col-resize" || document.body.style.cursor === "row-resize") {
            start_mouse_coords = [event.clientX, event.clientY];
            start_dimensions = [window_obj.offsetWidth, window_obj.offsetHeight];
            mouse_down = true;
          }
        });
        window_obj.addEventListener("mouseleave", () => {
          if (document.body.style.cursor === "col-resize" || document.body.style.cursor === "row-resize") {
            document.body.style.cursor = "auto";
          }
        });
        document.addEventListener("mouseup", () => {
          mouse_down = false;
          change = false;
          if (document.body.style.cursor === "col-resize" || document.body.style.cursor === "row-resize") {
            document.body.style.cursor = "auto";
          }
        });
        document.addEventListener("mousemove", (event) => {
          if (change === "x" && mouse_down) {
            window_obj.style.width = int_to_px(start_dimensions[0] + (event.clientX - start_mouse_coords[0]));
          } else if (change === "y" && mouse_down) {
            window_obj.style.height = int_to_px(start_dimensions[1] + (event.clientY - start_mouse_coords[1]));
          }
        });
        //also window moving
        window_obj.addEventListener("click", (event) => {
          //ignore if already current window
          if (current_window === window_obj.id.replace("-window", "")) return;
          change_current_window(window_obj.id.replace("-window", ""));
        });
      });

      function create_taskbar_tab(tab_name) {
        let tab = document.createElement("DIV");
        tab.classList.add("taskbar-tab", "inner-facing", "selected-tab");
        tab.id = `toolbar-tab-${tab_name.toLowerCase()}`;
        tab.textContent = tab_name;
        tab.onclick = () => {
          if (tab.classList.contains("outer-facing")) {
            change_current_window(tab_name.toLowerCase());
          }
        };
        document.getElementById("taskbar-tabs").appendChild(tab);
        recount_taskbar_tabs();
      }

      //opening the button window things
      function open_window(event, window_name) {
        let window_obj = document.getElementById(window_name.toLowerCase()+"-window");
        if (window_obj.style.display !== "block") {
          window_obj.style.display = "block";
          create_taskbar_tab(window_name);
          let iframe = document.getElementById("wikipedia-iframe");
          if (window_name.toLowerCase() === "wikipedia" && iframe.src === "") {
            iframe.src = "https://en.wikipedia.org/wiki/Main_Page";
          } else if (window_name.toLowerCase() === "minesweeper") {
            //reset game
            start_minesweeper();
          } else if (window_name.toLowerCase() === "calculator") {
            //these are defined later
            current_total = undefined;
            current_operation = undefined;
            current_value = undefined;
            document.getElementById("calc-input-actual").value = "not all buttons work";
            setTimeout(() => {
              if (document.getElementById("calc-input-actual").value === "not all buttons work") {
                document.getElementById("calc-input-actual").value = "0";
              }
            }, 1000);
          }
        }
        change_current_window(window_name.toLowerCase());
        if (event) event.stopPropagation();
      }

      //music util functions
      let notes = {"G#6":1661.22,"G6":1567.98,"F#6":1479.98,"F6":1396.91,"E6":1318.51,"D#6":1244.51,"D6":1174.66,"C#6":1108.73,"C6":1046.5,"B5":987.77,"A#5":932.33,"A5":880,"G#5":830.61,"G5":783.99,"F#5":739.99,"F5":698.46,"E5":659.26,"D#5":622.25,"D5":587.33,"C#5":554.37,"C5":523.25,"B4":493.88,"A#4":466.16,"A4":440,"G#4":415.3,"G4":392,"F#4":369.99,"F4":349.23,"E4":329.63,"D#4":311.13,"D4":293.66,"C#4":277.18,"C4":261.63,"B3":246.94,"A#3":233.08,"A3":220,"G#3":207.652,"G3":195.998,"F#3":184.997,"F3":174.614,"E3":164.814,"D#3":155.563,"D3":146.832,"C#3":138.591,"C3":130.813,"B2":123.47,"A#2":116.54,"A2":110,"G#2":103.83,"G2":97.99,"F#2":92.49,"F2":87.307,"E2":82.407,"D#2":77.78,"D2":73.416,"C#2":69.296,"C2":65.406};

      function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }

      function get_frequency(audio_context, destination, frequency, type) {
        let oscillator = audio_context.createOscillator();
        oscillator.type = type;
        oscillator.frequency.value = frequency;
        oscillator.connect(destination); //audio_context.destination
        return oscillator;
      }

      async function play_sound_file(sound_file) {
        const audio_context = new (window.AudioContext || window.webkitAudioContext)();
        //format is something like bpm100\nG3:G3::E3:E4
        let lines = sound_file.split("\n");
        let duration = 60000/(Number(lines[0].split(":")[0].replace("bpm","")));
        let type = lines[0].split(":")[1];
        let quick_rest = lines[0].split(":")[2] === "quick";
        lines.shift();
        let gain = audio_context.createGain();
        gain.gain.value = 0.2;
        gain.connect(audio_context.destination);
        for (let column=0; column < lines[0].split(":").length; column++) {
          let to_play = [];
          for (let line_num=0; line_num < lines.length; line_num++) {
            let value = lines[line_num].split(":")[column];
            if (!value) continue;
            to_play.push(get_frequency(audio_context, gain, notes[value], type));
          }
          to_play.forEach((item) => item.start());
          if (to_play.length === 0) {
            if (quick_rest) {
              if (duration < 250) {
                await sleep(20);
              } else {
                await sleep(50);
              }
            } else {
              await sleep(duration);
            }
          } else {
            await sleep(duration);
          }
          to_play.forEach((item) => item.stop());
          //await sleep(10);
        }
      }

      //file system
      let current_path = "/";

      let file_system = {
        "desktop": {
          //
        },
        "documents": {
          "resume.txt": "Nothing was paused, so there is nothing to resume.",
          "minesweeper.txt": "Win a game of minesweeper before you open me.",
          "browsers.txt": "I like Firefox, and loathe Safari. Chrome and Chromium-based browsers are icky because of Google but at least they keep up with web standards (or should I say, singlehandedly make them), and have minimal implementation bugs.",
        },
        "music": {
          "byoushin-wo-kamu.play": "bpm260:sawtooth\n::C#5:::::C#5::::C#5::::C#5::::C#5::::C#5:\nF#4:G#4::B4:F#4::G#4::G#4:F#4:G#4::B4:F#4:G#4::G#4:F#4:G#4::B4:F#4:G#4::G#4:G#4\n:E3:B3:E3:::F#3:A3:F#3:C#3:G#3:B3:G#3::D#3:F#3:D#3::E3:B3:E3::F#3:A3:F#3\nA2:::::B2::::::::G2::::A2::::B2:::",
          "hana-ni-bourei.play": "bpm230:triangle\nG#5::G#5:G#5:G#5:G#5:G#5:A5:G#5:F#5:E5::E5:E5:E5:E5:E5:E5:E5:F#5::E5:E5:G#5:F#5\n:::::::::::B4:::::::::::::\n:E4::B4:::::E4::B4::::::F#4::::::::\nF#3::::::::::::E3::B3::::::D#3::B3::\n:::::::B2:::::::::::::::::",
          "super-mario.play": "bpm290:triangle:quick\nE5:E5:::E5:::C5:::E5::::G5:::::\nA4:A4:::A4:::A4:::A4::::B4:::::\nF#4:F#4:::F#4:::F#4:::F#4::::G4:::::G4\n:::::::::::::::::::G3\nD2:D2:::D2:::D2:::D2::::G2:::::G2",
          "eulogy-nnom.play": "bpm200:square\nC4:::D4:::D#4::::D4:::D#4:::F4:::::G4:D#4:C4:G#3::::G#3::A#3:G3::::::::C4::D4:D#4::C4::D4::D#4:F4::D4::D#4::F4::G4::D#4::A#4:G#4:G4:G#4:F4:G4:D#4:F4:D4:D4:D4:D4:D4:D4:D4:D4\n:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::A#3:G#3:G3:G#3:F3:G3:D#3:F3:D3:D3:D3:D3:D3:D3:D3:D3\n:::::::::::::::::::::::::::::::C2:C2:::C2:C2:::C2:C2:::C2:C2:::C2:C2:::C2:C2:::C2:C2:::C2:C2:::C2:C2:::C2:C2:::C2:C2:::C2:C2",
          "yoru-ni-kakeru.play": "bpm300:square\n::::::::::::::::::::::::::::::::::::::::::G5::F5::D5::D#5:::D5:::::C5\nG4::A#4:C5::G#4::G4::F4::D#4::F4::C5::A#4::C5:G4:::F4::D#4:::::D#4::F4:::D4:::G#4::G4::G4::F4::D4::D#4:::D4:::A#4::\n:::::::::::::::::::::::::C4:::C4::::C4::::::::B3::::::::::::::A#3::C4\n:::::::::::::::::::::::::G3:::::::G#3::::::::G3::::::::::::::::G#3\n::::::::::::::::::::::::::::::::D#3::::::::D3::::::::::::::::F3",
          "super-idol.play": "bpm250:square\nD5:D5:D#5:D5:C5:D5:G4::C5:A#4:G4:A#4::C5::C5:C5:D5:C5:A#4:C5:D5::A#4:G4:G4:A#4:G4:A#4:G4::C5:D5:D#5:D5:C5:A#4:D5:C5::D5:G4::G4:A#4:A4::A4:A4:D5::D5::A#4",
          "info.txt": "I obviously did not make any of these songs.",
          "vocaloid.txt": "Hachi, n-buna, INABAKUMORI, CHINOZO, Paseri Onuma, Nayutan Seijin, Chiitana",
        },
        "dev": {
          "main.rs": "fn main() {\n  println!(\"Hola Mundo\");\n}",
          "hint4.rs": "fn main() {\n  let part_uno: String = String::from_utf8(vec![0b11111011 & 0b01010011, 0b11111001 & 0b01010010, 0b01000000 | 0b01000001, 0b0100111 << 1, 0b11001011 ^ 0b10000010, 0b11011111 & 0b01010011, 0b010010 >> 1 << 3, 0b001 << 5, 0b11111111 & 0b01010011]).unwrap();\n  let part_dos: String = String::from_utf8(vec![0b01001011+2]).unwrap()+&(i8::MAX-126).to_string();\n  println!(\"{}UNK BYE {}NES\", part_uno, part_dos);\n}",
          "count.bf": "i am absolutely horrid with thinking of algorithms (maybe thinking in general is my weak suit?) so the best brainfuck program i could make was this\nit takes an one digit input (0-9) then outputs a count of it\nlike if input is 8 the output is 12345678\n,------------------------------------------------>+++++++++++++.+++++++++++++++++++++++++++++++++++<[->+.<]",
          "pscript.md": "# PScript\nLines are not separated by newlines, but semicolons. Line numbers start from 1. Newlines are ignored, but allowed.\nComments start with `//` **right after a semicolon** (leading spaces after semicolon allowed and ignored).\n## PScript Keywords\n- `VAR`: first arg is variable name (must start with $), rest of args is terminal command to execute, the command's output is set to the variable's value.\n  `echo example text` can be used to set the value to 'example text', and `calculator mul 4 5` can be used to set the value to '20'.\n- `GOTO`: first arg is line number to go to.\n- `GOTOIF`: First arg is line number to go to if second arg (variable name) is equal to the output of the remaining args as a command.\n## Arguments\nArguments passed can be accessed in the script. Variable `$ARGS0` is the first argument, and so on.",
          "example.pscript": "VAR $A echo abcdefg;\nVAR $B calculator add 1 1;\n//basically, go to line 6 if var equals 'asdf';\nGOTOIF 8 $A echo asdf;\necho variable A is not 'asdf';\nGOTO 9;\n//^line 8;\necho this line will never run;\necho program ending;",
          "hola_mundo.pscript": "echo HOLA MUNDO",
          "jeff.pscript": "GOTOIF 4 $ARGS0 echo jeff;\necho set the first arg as 'jeff' and run again;\nGOTO 5;\necho Hi Jeff!;//line 5",
          "squared.pscript": "VAR $A calculator mul $ARGS0 $ARGS0; echo $A",
        },
      };

      function make_dir(dir_name) {
        if (current_path === "/") {
          file_system[dir_name] = {};
        } else {
          let dirs = current_path.split("/");
          //since path starts with "/", remove the empty string at start
          dirs.shift();
          let obj = file_system;
          for (let i=0; i < dirs.length; i++) {
            obj = obj[dirs[i]];
          }
          obj[dir_name] = {};
        }
      }

      //make or edit file
      function make_file(file_name, file_contents) {
        if (current_path === "/") {
          file_system[file_name] = file_contents;
        } else {
          let dirs = current_path.split("/");
          //since path starts with "/", remove the empty string at start
          dirs.shift();
          let obj = file_system;
          for (let i=0; i < dirs.length; i++) {
            obj = obj[dirs[i]];
          }
          obj[file_name] = file_contents;
        }
      }

      //delete file or directory
      function delete_obj(path) {
        let dirs = path.split("/");
        //since path starts with "/", remove the empty string at start
        dirs.shift();
        let obj = file_system;
        for (let i=0; i < dirs.length; i++) {
          if (i === dirs.length-1) {
            delete obj[dirs[i]];
          } else {
            obj = obj[dirs[i]];
          }
        }
      }

      function path_to_result(path) {
        if (path === "/") {
          return file_system;
        } else {
          let dirs = path.split("/");
          //since path starts with "/", remove the empty string at start
          dirs.shift();
          let obj = file_system;
          for (let i=0; i < dirs.length; i++) {
            obj = obj[dirs[i]];
            if (!obj) {
              return false;
            }
          }
          return obj;
        }
      }

      function path_to_obj(path) {
        let obj = path_to_result(path);
        if (typeof obj === "string") return false;
        return obj;
      }

      function get_file_contents(path) {
        let dirs = path.split("/");
        //since path starts with "/", remove the empty string at start
        dirs.shift();
        let obj = file_system;
        for (let i=0; i < dirs.length; i++) {
          obj = obj[dirs[i]];
          if (i === dirs.length-1 && typeof obj === "string") {
            return obj;
          }
          if (!obj) {
            return false;
          }
        }
      }

      //terminal
      const SUDO_PASSWORD = "F1D5EB7F3561DC137718BA7BD5D056BF635D0D6CEB08040A220B5241BDEC717C";
      const SECRET_TEXT = [
        {
          id: "secret-intro",
          encrypted: "8AC6C9520FFD1501A25C68CE8ED3925798407742901A5C27D7FA4EBD9C6E4D62144171D04085860C4D0E60091A6D532D054A4FD7ACF9230D33D9A9A8DB402A271DE4781F98E4DA576D7F9BEC98EF6F7DAF0772D1C74D6BB2CB1C2415B1FC501F93DCA38BDAE6D168255EE14AC6F391C749A0D782CD35FE3FF59CF23553EE05B2F8768887BB8169FC937498EB6909083DEBEA80A2BC556D7EC34FB22AE44F9BC96A4ED109B30B778EEF66CF167B6529245F4BA8D84A4765919012CB35E8DA5BFAF851C0AF06D2894D981F0B4C5672521E946F0D506AE43EDFF7112F012501E6A236903827E6D1A96734EE8C4975A1234173BF8190B50D32987AA74CD756F206",
          nonce: "74A8B1BD990FFAB9B87E3FE1B0B9F624"
        },
        {
          id: "secret-1",
          encrypted: "F2DA240C7CA7E936C7F5F6C7DECDF60C4F5A0A0E87D5AF",
          nonce: "2004F9014C4AA05A85FDA015F3870F4C"
        },
        {
          id: "secret-2",
          encrypted: "688B03EFB54A526E66CC0002BB306D2C0915C63F1F31B03F26C73ACC229FAEF54E861772FE6D386F497E11D98A2C805675D9C2B88FD15F2C374A3A2585C97A47",
          nonce: "3CDBE5731BE5836D18204D7B5969C114"
        },
        {
          id: "secret-3",
          encrypted: "AEFBA96CB4EA88567F4B326A57B2BD3F1DC2A5C6788378",
          nonce: "F6BDE68B3B2385B46CF7EA69E129DFBC"
        },
        {
          id: "secret-project",
          encrypted: "59F40807FBECB78318A96D2AC222F241DAA838130824F048033A95843972531631D8E18D778B953E7C0B12C3BC216AE540E84A900C10CEC5C03B94F1FA5F6F9F08B41D9B51382AD41C16E6F9BE7492B3ECC2F6C83E94826549557AFD1026F015477AD0C511E22BE701C3FF23316C4D82C2527013C3856108755763FB0A328F0FEC7254D326EC60B06C655203DA5185A497E4007FEBF56887E267EC47A065A283199DE40961A56E03E13F8744834073B5EE53597C504F7C9A04EB35806C28728AACB051CD008DC9651827ED3B3411B8446830291DF9A09E3A3C1FDA8ECB3594598A7C900D2E981F607EB9A37A03ACE91B1BC9BBA1EC88B3A8DE75A24433D0315A1D01A86F4C010CC1C0C40F064CBDD9736AF15098F6B5E2CCFD8F9A8F204A13905BB362CB153C5C67228A8EE6F16E24FB",
          nonce: "734061C45257FD84ABFDC2A6D1642C5A"
        }
      ];

      function utf8_to_uint8(utf8) {
        let uint8 = new Uint8Array(utf8.length);
        for (let i=0; i < utf8.length; i++) {
          uint8[i] = utf8.charCodeAt(i);
        }
        return uint8;
      }

      //hex should be even length, obviously
      function hex_to_uint8(hex) {
        let hex_chars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"];
        let uint8 = new Uint8Array(hex.length/2);
        for (let i=0; i < hex.length/2; i++) {
          uint8[i] = hex_chars.indexOf(hex[i*2])*16+hex_chars.indexOf(hex[i*2+1]);
        }
        return uint8;
      }

      function uint8_to_hex(uint8) {
        let hex_chars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"];
        let hex = "";
        for (let i=0; i < uint8.length; i++) {
          let first_char = Math.floor(uint8[i]/16);
          let second_char = uint8[i]%16;
          hex += hex_chars[first_char]+hex_chars[second_char];
        }
        return hex;
      }

      async function text_decrypt(encrypted, password, nonce) {
        let encrypted_bytes = hex_to_uint8(encrypted);
        nonce = hex_to_uint8(nonce);
        //single hash of password is 32 bytes, will be aes key
        let key_bytes = new Uint8Array(await window.crypto.subtle.digest("SHA-256", utf8_to_uint8(password)));
        //key bytes to key object
        let key = await crypto.subtle.importKey(
          "raw",
          key_bytes,
          "AES-CTR",
          true,
          ["encrypt", "decrypt"]
        );
        let decrypted_bytes = new Uint8Array(await window.crypto.subtle.decrypt(
          {
            name: "AES-CTR",
            counter: nonce,
            length: 64
          },
          key,
          encrypted_bytes
        ));
        return (new TextDecoder()).decode(decrypted_bytes);
      }

      let wallpaper_index = 0;
      let sudoed = false;

      async function evaluate_command(value, old_current_path) {
        let args = value.split(" ");
        let command = args.shift();
        let response;
        if (command === "help") {
          response = "Currently supported commands: help cd ls cat echo pwd clear wallpaper play loc cowsay start music programming minesweeper calculator terminal pscript";
          if (sudoed) {
            response += "\nand also mkdir, rm, touch";
          }
        } else if (command === "pwd") {
          response = current_path;
        } else if (command === "clear") {
          document.getElementById("terminal-responses").innerHTML = "";
          return;
        } else if (command === "cd") {
          if (args[0]) {
            if (args[0].endsWith("..")) {
              //easier than fixing the root cause
              args[0] += "/";
            }
            if ((args[0].startsWith("../") || args[0] === "..") && old_current_path !== "/") {
              while (true) {
                let splitted = current_path.split("/");
                let popped = splitted.pop();
                if (popped === "") {
                  //the .. was invalid
                  break;
                }
                current_path = splitted.join("/");
                if (current_path === "") {
                  current_path = "/";
                }
                //replaces one
                if (args[0].startsWith("../")) {
                  args[0] = args[0].replace("../", "");
                } else if (args[0] === "..") {
                  args[0] = "";
                }
                if (!args[0].startsWith("../")) break;
              }
            }
          }
          if (current_path.endsWith("/")) {
            current_path += args[0];
          } else if (args[0] !== "") {
            current_path += "/"+args[0];
          }
          if (!path_to_obj(current_path)) {
            current_path = old_current_path;
            response = "Requested path does not exist";
          } else {
            response = "";
          }
        } else if (command === "ls") {
          response = Object.keys(path_to_obj(current_path)).join(", ");
          if (response.trim() === "") {
            response = "Nothing here";
          }
        } else if (command === "echo") {
          response = args.join(" ");
        } else if (command === "cat") {
          //remove leading /
          if (args[0].startsWith("/")) {
            args[0] = args[0].slice(1, args[0].length);
          }
          if (current_path.endsWith("/")) {
            response = get_file_contents(current_path+args[0]);
          } else {
            response = get_file_contents(current_path+"/"+args[0]);
          }
          if (response === false) {
            response = "Could not find file. `..` are not supported with the cat command";
          }
        } else if (command === "start" || command === "music" || command === "programming" || command === "minesweeper") {
          open_window(false, command);
          response = `Opened ${command}`;
        } else if (command === "calculator") {
          let first_arg = args.shift();
          if (first_arg) {
            let total = Number(args[0]);
            for (let i=1; i < args.length; i++) {
              if (first_arg === "add") {
                total += Number(args[i]);
              } else if (first_arg === "sub") {
                total -= Number(args[i]);
              } else if (first_arg === "mul") {
                total *= Number(args[i]);
              } else if (first_arg === "div") {
                total /= Number(args[i]);
              }
            }
            response = String(total);
          } else {
            open_window(false, command);
            response = `Opened calculator`;
          }
        } else if (command === "terminal") {
          response = "Hmm...";
        } else if (command === "sudo") {
          let password = args[0];
          if (!password) {
            response = "Include password as the first argument"
          } else {
            //double hash, since single hash is used as encryption key
            let hashed = uint8_to_hex(new Uint8Array(await window.crypto.subtle.digest("SHA-256", new Uint8Array(await window.crypto.subtle.digest("SHA-256", utf8_to_uint8(password))))));
            if (hashed === SUDO_PASSWORD) {
              sudoed = true;
              response = "Success!";
              open_window(false, "Himitsu");
              for (let i=0; i < SECRET_TEXT.length; i++) {
                let secret = SECRET_TEXT[i];
                document.getElementById(secret.id).textContent = await text_decrypt(secret.encrypted, password, secret.nonce);
              }
            } else if (args[0] === "password") {
              response = "Success! Just kidding. Wrong password.";
            } else {
              response = `Wrong password: ${["remember, all lowercase", "remember, separated by hyphens", "remember, there are four parts, five dashes, six words", "remember, three out of four are king related"][Math.floor(Math.random()*4)]}`;
            }
          }
        } else if (command === "wallpaper") {
          let wallpapers = [
            {
              type: "backgroundColor",
              value: "var(--desktop-background)",
            },
            {
              type: "backgroundColor",
              value: "var(--desktop-background2)",
            },
            {
              type: "backgroundColor",
              value: "var(--desktop-background3)",
            },
            {
              type: "backgroundColor",
              value: "var(--desktop-background4)",
            },
            {
              type: "backgroundColor",
              value: "var(--desktop-background5)",
            },
            {
              type: "backgroundColor",
              value: "var(--desktop-background6)",
            },
            {
              type: "backgroundColor",
              value: "white",
            },
            {
              type: "backgroundImage",
              value: "linear-gradient(to right, var(--desktop-background), green)",
            },
            {
              type: "backgroundImage",
              value: "linear-gradient(black, white, black)",
            },
            {
              //the ztmy gradient
              type: "backgroundImage",
              value: "linear-gradient(to right, #BC0ABF, #7D45AA, #47168B)",
            },
          ];
          if (!args[0] || !(["next", "back", "url"].includes(args[0]))) {
            response = "Do `wallpaper next` and `wallpaper back` to cycle through desktop wallpapers\nor do wallpaper url https://example.com/example.png";
          } else {
            if (args[0] === "next" || args[0] === "back") {
              if (args[0] === "next") {
                wallpaper_index++;
                if (wallpaper_index > wallpapers.length-1) {
                  wallpaper_index = 0;
                }
              } else if (args[0] === "back") {
                wallpaper_index--;
                if (wallpaper_index < 0) {
                  wallpaper_index = wallpapers.length-1;
                }
              }
              //reset old wallpaper
              document.getElementById("desktop").style.backgroundImage = "";
              //set new wallpaper
              let new_wallpaper = wallpapers[wallpaper_index];
              document.getElementById("desktop").style[new_wallpaper.type] = new_wallpaper.value;
              response = "Wallpaper changed";
            }
            if (args[0] === "url") {
              if (!args[1]) {
                response = "Missing second arg, it should be the image url";
              } else if (!args[1].startsWith("http")) {
                response = "Second arg doesn't seem to be a url, must start with 'http'";
              } else {
                document.getElementById("desktop").style.backgroundImage = `url("${args[1]}")`;
                response = "Wallpaper changed";
              }
            }
          }
        } else if (command === "play") {
          if (!args[0]) {
            response = "First argument should be .play file to play";
          } else {
            if (!args[0].endsWith(".play")) {
              response = "File is not a .play file";
            } else {
              if (args[0].startsWith("/")) {
                args[0] = args[0].slice(1, args[0].length);
              }
              let file_contents;
              if (current_path.endsWith("/")) {
                file_contents = get_file_contents(current_path+args[0]);
              } else {
                file_contents = get_file_contents(current_path+"/"+args[0]);
              }
              if (!file_contents) {
                response = "Could not find file. `..` are not supported with the play command";
              } else {
                play_sound_file(file_contents);
                response = "Playing";
              }
            }
          }
        } else if (command === "loc") {
          response = `Lines of Javascript on this page: ${document.querySelector("script").innerText.split("\n").length}`;
        } else if (command === "cowsay") {
          let cow_speech = args.join(" ");
          response = " ________________________________________\n/ ";
          if (cow_speech.length > 38) {
            for (let i=0; i < Math.ceil(cow_speech.length/38); i++) {
              let line = cow_speech.slice(38*i, 38*(i+1));
              if (i === 0) {
                //if first line
                response += line+"\\";
              } else if (i === Math.ceil(cow_speech.length/38)-1) {
                //if last line
                response += " \n\\ "+line+" ".repeat(38-line.length)+" /";
              } else {
                response += " \n| "+line+" |";
              }
            }
          } else {
            response += cow_speech+" ".repeat(39-cow_speech.length)+"\\\n\\"+" ".repeat(40)+"/";
          }
          response += "\n ----------------------------------------\n        \\   ^__^\n         \\  (oo)\\_______\n            (__)\\       )\\/\\\n                ||----w |\n                ||     ||";
        } else if (command === "pscript") {
          if (!args[0]) {
            response = "Runs the PScript 'Language', first arg can be .pscript file (.. not allowed) or if first arg does not end in .pscript, the args will be combined and run instead";
          } else {
            if (args[0].endsWith(".pscript")) {
              let file = args.shift();
              //remove leading /
              if (file.startsWith("/")) {
                file = file.slice(1, file.length);
              }
              if (file.includes("/")) {
                response = "PScript file must be in same directory";
              } else {
                let file_contents;
                if (current_path.endsWith("/")) {
                  file_contents = get_file_contents(current_path+file);
                } else {
                  file_contents = get_file_contents(current_path+"/"+file);
                }
                if (file_contents === false) {
                  response = "Could not find file. `..` are not supported with the pscript command";
                } else {
                  response = await run_pscript(file_contents, args);
                }
              }
            } else {
              response = await run_pscript(args.join(" "), []);
            }
          }
        } else if (command === "npm" && args[0] === "install") {
          response = "[████████] Installing 700000 GB of packages..."
        } else if (command.replace("-", "").toLowerCase() === "commandprompt") {
          response = "Look, I know the terminal is called command prompt or power shell in windows but I don't care. It's a fucking terminal.";
        } else if (sudoed && ["mkdir", "rm", "touch"].includes(command)) {
          if (command === "mkdir") {
            if (!args[0]) {
              response = "First arg should be new directory name to create in current directory";
            } else {
              if (args[0].includes("/") || args[0].includes(".")) {
                response = "New directory must be in current directory, and not be a file";
              } else {
                //check if directory already exists
                let current_dir = path_to_obj(current_path);
                if (current_dir[args[0]]) {
                  response = "Directory with that name already exists here";
                } else {
                  make_dir(args[0]);
                  response = "Created directory";
                }
              }
            }
          } else if (command === "touch") {
            let file_name = args.shift();
            if (!file_name) {
              response = "First arg is file to create/edit in current directory, rest of args are new file contents";
            } else {
              if (!file_name.includes(".")) {
                response = "File must have file extension";
              } else if (file_name.includes("/")) {
                response = "New file must be created in current directory";
              } else {
                let try_path;
                if (current_path === "/") {
                  try_path = current_path+file_name;
                } else {
                  try_path = current_path+"/"+file_name;
                }
                //check if file already exists
                if (path_to_result(try_path)) {
                  response = "File or directory with that name already exists here";
                } else {
                  make_file(file_name, args.join(" "));
                  response = "Created file";
                }
              }
            }
          } else if (command === "rm") {
            let remove_name = args.shift();
            if (!remove_name) {
              response = "First arg should be directory or file in current directory to remove";
            } else {
              let try_path;
              if (current_path === "/") {
                try_path = current_path+remove_name;
              } else {
                try_path = current_path+"/"+remove_name;
              }
              //check if file/directory exists
              if (path_to_result(try_path)) {
                delete_obj(try_path);
                response = "Removed file/directory";
              } else {
                response = "That file/directory doesn't exist, so nothing to remove";
              }
            }
          }
        } else {
          response = "Lo siento, unrecognized command. Type 'help' for a list of commands"
        }
        return response;
      }

      function gen_error(error, output, debug) {
        if (!debug) {
          return error;
        } else {
          return `${output}\n${error}`;
        }
      }

      //could be a problem if a vars value is another var...
      function replace_vars(command, vars) {
        let keys = Object.keys(vars);
        for (let i=0; i < keys.length; i++) {
          command = command.replaceAll(keys[i], vars[keys[i]]);
        }
        return command;
      }

      async function run_line(lines, current_index, output, iterations, vars, debug=false) {
        iterations++;
        let value = lines[current_index].trim();
        if (iterations > 1000) {
          //going on for too long. terminate
          return gen_error("Error, more than 1000 iterations", output, debug);
        }
        //run the line
        let splitted = value.split(" ");
        let first = splitted.shift();
        if (first === "VAR") {
          let var_name = splitted.shift();
          if (!var_name?.startsWith("$")) {
            return gen_error("First arg must be variable name, which must start with $", output, debug);
          }
          let var_value = await evaluate_command(replace_vars(splitted.join(" "), vars), current_path);
          vars[var_name] = var_value;
        } else if (first === "GOTO") {
          let goto_line = Number(splitted[0]);
          if (isNaN(goto_line)) {
            return gen_error("First arg must be line number to go to", output, debug);
          } else if (goto_line > lines.length || goto_line <= 0) {
            return gen_error("Line number does not exist", output, debug);
          }
          current_index++;
          return await run_line(lines, goto_line-1, output, iterations, vars, debug);
        } else if (first === "GOTOIF") {
          let goto_line = Number(splitted.shift()); //first arg
          if (isNaN(goto_line)) {
            return gen_error("First arg must be line number to go to", output, debug);
          } else if (goto_line > lines.length || goto_line <= 0) {
            return gen_error("Line number does not exist", output, debug);
          }
          let var_name = splitted.shift(); //second arg
          if (!var_name?.startsWith("$")) {
            return gen_error("Second arg must be variable, which must start with $", output, debug);
          }
          if (vars[var_name] === undefined) {
            return gen_error(`Variable "${var_name}" undefined`, output, debug)
          }
          //syntax example: GOTOIF 8 $A echo asdf
          let result = await evaluate_command(replace_vars(splitted.join(" "), vars), current_path);
          if (result === vars[var_name]) {
            //goto line
            current_index++;
            return await run_line(lines, goto_line-1, output, iterations, vars, debug);
          }
        } else if (!first.startsWith("//") && first !== "") {
          //assume it is a command, ignore if starts with // because thats a comment
          if (output !== "") {
            output += "\n"+await evaluate_command(replace_vars(value, vars), current_path);
          } else {
            output += await evaluate_command(replace_vars(value, vars), current_path);
          }
        }
        //if last line, end
        if (current_index === lines.length-1) return output;
        //else, move to next index and keep running
        current_index++;
        return await run_line(lines, current_index, output, iterations, vars, debug);
      }

      async function run_pscript(script_content, args, debug=false) {
        //prussia script
        //ignore newlines because we are a semicolon household
        script_content = script_content.split("\n").join("");
        let lines = script_content.split(";").map((item) => item.trim());
        let vars = {};
        for (let i=0; i < args.length; i++) {
          vars[`$ARGS${i}`] = args[i];
        }
        return await run_line(lines, 0, "", 0, vars, debug);
      }

      document.getElementById("terminal-command-input").onkeydown = async (event) => {
        //enter key
        if (event.keyCode === 13) {
          let old_current_path = current_path;
          let value = document.getElementById("terminal-command-input").value;
          document.getElementById("terminal-command-input").value = "";
          let response = await evaluate_command(value, old_current_path);
          let result_ele = document.createElement("DIV");
          let command_ele = document.createElement("P");
          command_ele.textContent = `${old_current_path}> ${value}`;
          result_ele.appendChild(command_ele);
          let response_ele = document.createElement("P");
          response_ele.innerText = response;
          result_ele.classList.add("terminal-response");
          result_ele.appendChild(response_ele);
          document.getElementById("terminal-responses").appendChild(result_ele);
          document.getElementById("current-path").textContent = current_path+">";
          document.getElementById("terminal-input-container").style.gridTemplateColumns = `${current_path.length+2}ch auto`;
          let window_content = document.getElementById("terminal-window").querySelector(".window-content");
          window_content.scrollTo(0, window_content.scrollHeight);
        }
      };

      //blackbeard
      class Canvas {
        /**
         * @param {number[]} size
         * @param {string} id
         * @param {HTMLElement} parent
         */
        constructor(size, id, parent=undefined, contextOptions=undefined) {
          this.size = size;
          this.canvas = document.createElement("CANVAS");
          this.canvas.id = id;
          this.canvas.width = size[0];
          this.canvas.height = size[1];
          this.canvas.tabIndex = 1;
          if (!parent) {
            document.body.appendChild(this.canvas);
          } else {
            parent.appendChild(this.canvas);
          }
          this.context = this.canvas.getContext('2d', contextOptions);
          this.components = [];
          this.events = {};
          //this.event_functions is not meant to be read. internal use only
          this.event_functions = {};
          this.frame = 0;
          this.click_temp_disabled = false;
        }
        update() {
          this.frame += 1;
          this.clear();
          //copy the components to account for any component deletions/additions,
          //while running .update() for the components
          let components_snapshot = this.components.slice();
          for (let i=0; i < components_snapshot.length; i++) {
            components_snapshot[i].update();
          }
        }
        clear() {
          this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }
        reset() {
          this.components = [];
          document.body.style.cursor = "default";
          //dont forget to remove all event listeners
          for (let i=0; i < Object.keys(this.event_functions).length; i++) {
            let event = Object.keys(this.event_functions)[i];
            let event_function = this.event_functions[event];
            this.canvas.removeEventListener(event, event_function);
          }
          this.event_functions = {};
          this.events = {};
        }
        //new (name: string) => any means any class (eg TextButton)
        /**
         * @param {string} event
         * @param {[new (name: string) => any]} objects
         * @param {boolean} [overwrite=false]
         */
        addEvent(event, objects, overwrite=false) {
          //prevent overwriting
          if (this.events[event] && !overwrite) {
            this.events[event] = [].concat(this.events[event], objects);
          } else if (!this.events[event]) {
            this.events[event] = objects;
            //to make sure multiple event listeners arent added, only add the listener the first time addEvent() is called for event, after a reset/start. simplified; we only need one event listener per event, prevent there being multiple
            //add components to the event separately
            let self = this;
            function canvasEventHandler(e) {
              self.clearDeadEvents();
              let event_items = self.events[event];
              if (!event_items) {
                return;
              }
              for (let i=0; i < event_items.length; i++) {
                let component = event_items[i];
                component[event](e);
              }
              if (e.type === "contextmenu" || e.type === "scroll") {
                return false;
              }
            }
            this.canvas.addEventListener(event, canvasEventHandler);
            this.event_functions[event] = canvasEventHandler;
          } else {
            this.events[event] = objects;
          }
        }
        //when components no longer exist, get rid of the events for them too
        clearDeadEvents() {
          for (let i=0; i < Object.keys(this.events).length; i++) {
            let event_name = Object.keys(this.events)[i];
            for (let j=0; j < this.events[event_name].length; j++) {
              let obj = this.events[event_name][j];
              //if component no longer exists
              if (!this.components.includes(obj)) {
                this.events[event_name].splice(j, 1);
              }
            }
          }
        }
      }

      class MineGrid {
        constructor(canvas) {
          //generate mines
          this.minefield = MineGrid.generate_minefield();
          this.first_click = true;
          //state is playing, lost, or won
          this.game_state = "playing";
          this.canvas = canvas;
          //add click event
          this.canvas.addEvent("click", [this], false);
          //add to components
          this.canvas.components.push(this);
        }
        static generate_minefield() {
          //10% of squares should have mines, roughly
          let minefield = [];
          for (let row=0; row < 10; row++) {
            let row = [];
            for (let column=0; column < 10; column++) {
              if (Math.random() < 0.1) {
                row.push({
                  mine: true,
                  revealed: false,
                });
              } else {
                row.push({
                  mine: false,
                  //placeholder
                  mines_touching: 0,
                  revealed: false,
                });
              }
            }
            minefield.push(row);
          }
          //calculate mines touching each non mine square
          for (let row=0; row < 10; row++) {
            for (let column=0; column < 10; column++) {
              if (minefield[row][column].mine) continue;
              let mines_touching = 0;
              //I am aware I could probably just do this.minefield[row-1]?[column-1]?.mine but I feel like the protective if statements are better
              //upper left
              if (row !== 0 && column !== 0) {
                if (minefield[row-1][column-1].mine) {
                  mines_touching++;
                }
              }
              //directly up
              if (row !== 0) {
                if (minefield[row-1][column].mine) {
                  mines_touching++;
                }
              }
              //upper right
              if (row !== 0 && column !== 9) {
                if (minefield[row-1][column+1].mine) {
                  mines_touching++;
                }
              }
              //directly left
              if (column !== 0) {
                if (minefield[row][column-1].mine) {
                  mines_touching++;
                }
              }
              //directly right
              if (column !== 9) {
                if (minefield[row][column+1].mine) {
                  mines_touching++;
                }
              }
              //lower left
              if (row !== 9 && column !== 0) {
                if (minefield[row+1][column-1].mine) {
                  mines_touching++;
                }
              }
              //directly lower
              if (row !== 9) {
                if (minefield[row+1][column].mine) {
                  mines_touching++;
                }
              }
              //lower right
              if (row !== 9 && column !== 9) {
                if (minefield[row+1][column+1].mine) {
                  mines_touching++;
                }
              }
              //update mines touching
              minefield[row][column].mines_touching = mines_touching;
            }
          }
          return minefield;
        }
        click(event) {
          if (this.game_state !== "playing") return;
          const CORNER_HEIGHT = 5;
          let adjusted_x = event.offsetX - CORNER_HEIGHT;
          let adjusted_y = event.offsetY - CORNER_HEIGHT;
          if (adjusted_x < 0 || adjusted_y < 0) return;
          if (adjusted_x > 270-CORNER_HEIGHT-5 || adjusted_y > 270-CORNER_HEIGHT-5) return;
          const tile_dimension = (270-CORNER_HEIGHT*2)/10;
          let tile_x = Math.floor(adjusted_x/tile_dimension);
          let tile_y = Math.floor(adjusted_y/tile_dimension);
          let tile = this.minefield[tile_y][tile_x];
          if (this.first_click) {
            this.first_click = false;
            if (tile.mine || tile.mines_touching !== 0) {
              //regenerate minefield, until it starts on a square without any mines touching
              while (true) {
                this.minefield = MineGrid.generate_minefield();
                tile = this.minefield[tile_y][tile_x];
                if (!tile.mine && tile.mines_touching === 0) {
                  break;
                }
              }
            }
          }
          //tile already clicked
          if (tile.revealed) return;
          this.minefield[tile_y][tile_x].revealed = true;
          //now see if its a mine, or empty, or a number
          if (tile.mine) {
            this.game_state = "lost";
            //announce loss
            document.getElementById("minesweeper-status").textContent = "- You lost!";
          } else {
            if (tile.mines_touching === 0) {
              //open all neighbouring tiles
              //values should be unique, but these are arrays. so turn them into json. kinda hacky, sorry
              let queue = new Set([JSON.stringify([tile_x, tile_y])]);
              Set.prototype.json_add = function (item) {
                this.add(JSON.stringify(item));
              }
              while (true) {
                if (queue.size === 0) break;
                let q_first = JSON.parse(queue.values().next().value);
                let q_x = q_first[0];
                let q_y = q_first[1];
                let q_tile = this.minefield[q_y][q_x];
                if (q_tile.mines_touching === 0 && !queue.revealed) {
                  //add surrounding tiles
                  if (q_y !== 0) {
                    //upper left
                    if (q_x !== 0 && !this.minefield[q_y-1][q_x-1].revealed) {
                      queue.json_add([q_x-1, q_y-1]);
                    }
                    //directly upper
                    if (!this.minefield[q_y-1][q_x].revealed) {
                      queue.json_add([q_x, q_y-1]);
                    }
                    //upper right
                    if (q_x !== 9 && !this.minefield[q_y-1][q_x+1].revealed) {
                      queue.json_add([q_x+1, q_y-1]);
                    }
                  }
                  if (q_x !== 0 && !this.minefield[q_y][q_x-1].revealed) {
                    //directly left
                    queue.json_add([q_x-1, q_y]);
                  }
                  if (q_x !== 9 && !this.minefield[q_y][q_x+1].revealed) {
                    //directly right
                    queue.json_add([q_x+1, q_y]);
                  }
                  if (q_y !== 9) {
                    //lower left
                    if (q_x !== 0 && !this.minefield[q_y+1][q_x-1].revealed) {
                      queue.json_add([q_x-1, q_y+1]);
                    }
                    //directly lower
                    if (!this.minefield[q_y+1][q_x].revealed) {
                      queue.json_add([q_x, q_y+1]);
                    }
                    //lower right
                    if (q_x !== 9 && !this.minefield[q_y+1][q_x+1].revealed) {
                      queue.json_add([q_x+1, q_y+1]);
                    }
                  }
                }
                this.minefield[q_y][q_x].revealed = true;
                queue.delete(JSON.stringify([q_x, q_y]));
              }
            }
            //check for victory
            let won = [].concat(...this.minefield).every((item) => {
              return (!item.mine && !item.revealed) ? false : true;
            });
            if (won) {
              const DARK = "#808080";
              this.game_state = "won";
              //announce win
              document.getElementById("minesweeper-status").textContent = "- You won!";
              file_system["documents"]["minesweeper.txt"] = "In case you couldn't read the hint at the bottom left of the minesweeper window, it says 'hint1 chinese monkey king'. Oh uh and don't forget that you can play another round by closing and reopening the window.";
            }
          }
          //finally, update canvas
          canvas.update();
        }
        update() {
          const DARK = "#808080";
          const LIGHT = "white";
          const NORMAL = "#c0c0c0";
          //draw the corners of the field
          const CORNER_HEIGHT = 5;
          let top = new Path2D();
          top.moveTo(0, 0);
          top.lineTo(270, 0);
          top.lineTo(270-CORNER_HEIGHT, CORNER_HEIGHT);
          top.lineTo(0, CORNER_HEIGHT);
          top.lineTo(0, 0);
          this.canvas.context.fillStyle = DARK;
          this.canvas.context.fill(top);
          let left = new Path2D();
          left.moveTo(0, 0);
          left.lineTo(0, 270);
          left.lineTo(CORNER_HEIGHT, 270-CORNER_HEIGHT);
          left.lineTo(CORNER_HEIGHT, 0);
          left.lineTo(0, 0);
          this.canvas.context.fill(left);
          let right = new Path2D();
          right.moveTo(270, 0);
          right.lineTo(270, 270);
          right.lineTo(270-CORNER_HEIGHT, 270);
          right.lineTo(270-CORNER_HEIGHT, CORNER_HEIGHT);
          right.lineTo(270, 0);
          this.canvas.context.fillStyle = LIGHT;
          this.canvas.context.fill(right);
          let bottom = new Path2D();
          bottom.moveTo(0, 270);
          bottom.lineTo(270, 270);
          bottom.lineTo(270, 270-CORNER_HEIGHT);
          bottom.lineTo(CORNER_HEIGHT, 270-CORNER_HEIGHT);
          bottom.lineTo(0, 270);
          this.canvas.context.fill(bottom);
          if (this.game_state === "won") {
            this.canvas.context.font = "8px Arial";
            this.canvas.context.fillStyle = "gray";
            this.canvas.context.fillText("hint1 chinese monkey king", 5, 270);
          }
          //10x10 mines, canvas is 270x270
          const CORNER_HEIGHT_TILE = 3;
          const tile_dimension = (270-CORNER_HEIGHT*2)/10;
          for (let row_num=0; row_num < 10; row_num++) {
            let row = this.minefield[row_num];
            for (let column_num=0; column_num < 10; column_num++) {
              let tile = row[column_num];
              //technically top left
              let top_x = tile_dimension*column_num+CORNER_HEIGHT;
              let top_y = tile_dimension*row_num+CORNER_HEIGHT;
              //square
              this.canvas.context.fillStyle = NORMAL;
              this.canvas.context.fillRect(top_x, top_y, tile_dimension, tile_dimension);
              this.canvas.context.lineWidth = 2;
              this.canvas.context.strokeStyle = DARK;
              this.canvas.context.strokeRect(top_x, top_y, tile_dimension, tile_dimension);
              //technically bottom right
              let bottom_x = top_x+tile_dimension;
              let bottom_y = top_y+tile_dimension;
              if (tile.revealed) {
                if (tile.mine) {
                  let x_left = new Path2D();
                  x_left.moveTo(top_x, top_y);
                  x_left.lineTo(bottom_x, bottom_y);
                  this.canvas.context.strokeStyle = "red";
                  this.canvas.context.lineWidth = 2;
                  this.canvas.context.stroke(x_left);
                  let x_right = new Path2D();
                  x_right.moveTo(top_x, bottom_y);
                  x_right.lineTo(bottom_x, top_y);
                  this.canvas.context.stroke(x_right);
                } else {
                  if (tile.mines_touching > 0) {
                    //coords is bottom left of text
                    const font_size = 18;
                    this.canvas.context.font = `bold ${font_size}px Arial`;
                    let fill_color;
                    switch (tile.mines_touching) {
                      case 1:
                        fill_color = "blue";
                        break;
                      case 2:
                        fill_color = "green";
                        break;
                      case 3:
                        fill_color = "red";
                        break;
                      case 4:
                        fill_color = "purple";
                        break;
                      case 5:
                        fill_color = "maroon";
                        break;
                      case 6:
                        fill_color = "aquamarine";
                        break;
                      case 7:
                        fill_color = "black";
                        break;
                      case 8:
                        fill_color = "gray";
                        break;
                      default:
                        //not possible
                        fill_color = "black";
                    }
                    let text_width = this.canvas.context.measureText(String(tile.mines_touching)).width;
                    this.canvas.context.fillStyle = fill_color;
                    this.canvas.context.fillText(String(tile.mines_touching), top_x+Math.round((tile_dimension-text_width)/2), bottom_y-(tile_dimension-font_size));
                  }
                }
              } else {
                //draw corners
                let tile_top = new Path2D();
                tile_top.moveTo(top_x, top_y);
                tile_top.lineTo(bottom_x, top_y);
                tile_top.lineTo(bottom_x-CORNER_HEIGHT_TILE, top_y+CORNER_HEIGHT_TILE);
                tile_top.lineTo(top_x, top_y+CORNER_HEIGHT_TILE);
                tile_top.lineTo(top_x, top_y);
                this.canvas.context.fillStyle = LIGHT;
                this.canvas.context.fill(tile_top);
                let tile_left = new Path2D();
                tile_left.moveTo(top_x, top_y);
                tile_left.lineTo(top_x, bottom_y);
                tile_left.lineTo(top_x+CORNER_HEIGHT_TILE, bottom_y-CORNER_HEIGHT_TILE);
                tile_left.lineTo(top_x+CORNER_HEIGHT_TILE, top_y);
                tile_left.lineTo(top_x, top_y);
                this.canvas.context.fill(tile_left);
                let tile_right = new Path2D();
                tile_right.moveTo(bottom_x, top_y);
                tile_right.lineTo(bottom_x, bottom_y);
                tile_right.lineTo(bottom_x-CORNER_HEIGHT_TILE, bottom_y);
                tile_right.lineTo(bottom_x-CORNER_HEIGHT_TILE, top_y+CORNER_HEIGHT_TILE);
                tile_right.lineTo(bottom_x, top_y);
                this.canvas.context.fillStyle = DARK;
                this.canvas.context.fill(tile_right);
                let tile_bottom = new Path2D();
                tile_bottom.moveTo(top_x, bottom_y);
                tile_bottom.lineTo(bottom_x, bottom_y);
                tile_bottom.lineTo(bottom_x, bottom_y-CORNER_HEIGHT_TILE);
                tile_bottom.lineTo(top_x+CORNER_HEIGHT_TILE, bottom_y-CORNER_HEIGHT_TILE);
                tile_bottom.lineTo(top_x, bottom_y);
                this.canvas.context.fill(tile_bottom);
              }
            }
          }
        }
      }

      let canvas = new Canvas([270, 270], "minesweeper-canvas", document.getElementById("minesweeper-container"));

      function start_minesweeper() {
        document.getElementById("minesweeper-status").textContent = "";
        canvas.reset();
        new MineGrid(canvas);
        canvas.update();
      }

      //calculator
      //the total number after operation
      let current_total;
      //the number or string or whatever displayed on screen
      let current_operation;
      let current_value;
      let calc_memory = 0;
      function calc_click_handler() {
        let value = this.textContent;
        //0, 1, 2, 3, etc
        if (!isNaN(Number(value))) {
          //dont allow the length to overflow the screen
          if (current_value?.length > 25) return;
          if (!isNaN(Number(current_value))) {
            if (Number(current_value) === 0 && current_value !== "0.") {
              current_value = value;
            } else {
              //not an operation, so add the number as a string to current value
              current_value += value;
            }
          } else {
            //after some sort of operation, or undefined, so set it to the number
            current_value = value;
          }
        } else if (value === ".") {
          if (current_value?.length > 25) return;
          if (!isNaN(Number(current_value))) {
            current_value += ".";
          }
        } else if (value === "+/-") {
          if (!isNaN(Number(current_value))) {
            current_value = String(-Number(current_value));
          }
        } else if (value === "CE") {
          //only clear current value and operation
          current_value = undefined;
          current_operation = undefined;
        } else if (value === "C") {
          current_value = undefined;
          current_operation = undefined;
          current_total = undefined;
        } else if (value === "MC") {
          calc_memory = 0;
        } else if (value === "MR") {
          current_value = String(calc_memory);
        } else if (value === "MS") {
          calc_memory = current_total;
        } else if (value === "M+") {
          calc_memory += current_total;
        } else if (!isNaN(current_value)) {
          //^ current value has to be a number and not an operation or something else
          if (value === "+" || value === "-" || value === "*" || value === "/") {
            current_total = Number(current_value);
            current_operation = value;
            current_value = value;
          } else if (value === "=") {
            //do the current operation
            if (current_operation === "+") {
              current_total += Number(current_value);
            } else if (current_operation === "-") {
              current_total -= Number(current_value);
            } else if (current_operation === "*") {
              current_total *= Number(current_value);
            } else if (current_operation === "/") {
              current_total /= Number(current_value);
            } else if (!current_operation) {
              current_total = Number(current_value)
            }
            current_value = current_total;
            current_operation = undefined;
          } else if (value === "sqrt") { //`&& Number(current_value) === current_total` will make sure square root only done on totals, but maybe not needed?
            current_value = String(Math.sqrt(Number(current_value)));
          }
        }
        //
        document.getElementById("calc-input-actual").value = current_value === undefined ? "0" : current_value;
      }

      document.querySelectorAll(".calc-btn").forEach((item) => item.onclick = calc_click_handler);

      //query params
      let params = new URLSearchParams(window.location.search);
      if (params.get("open_windows")) {
        let windows_to_open = params.get("open_windows").split(",");
        for (let i=0; i < windows_to_open.length; i++) {
          //make sure window exists
          if (document.getElementById(windows_to_open[i].toLowerCase()+"-window")) {
            open_window(undefined, windows_to_open[i]);
          }
        }
      }
      if (params.get("background")) {
        evaluate_command(`wallpaper url ${params.get("background")}`);
      }

      //taskbar start
      document.getElementById("taskbar-start").onclick = () => {
        if (document.getElementById("start-window").style.display === "none") {
          document.getElementById("start-window").style.display = "block";
          create_taskbar_tab("Start");
        }
      };

      create_taskbar_tab("Start");
    </script>
  </body>
</html>
